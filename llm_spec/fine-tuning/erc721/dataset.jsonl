{"messages": [{"role": "system", "content": "You are a coding assistant specialized in generating formal postconditions for ERC interface with solc-verify postconditions annotations."},{"role": "user", "content": "/**\n * @notice Count all NFTs assigned to an owner\n * @dev NFTs assigned to the zero address are considered invalid, and this function throws for queries about the zero address.\n * @param _owner An address for whom to query the balance\n * @return The number of NFTs owned by `_owner`, possibly zero\n*/\nfunction balanceOf(address _owner) external view returns (uint256 balance);"},{"role": "assistant", "content": "/// @notice postcondition _ownedTokensCount[_owner] == balance\nfunction balanceOf(address _owner) public view returns (uint256 balance);"}]}
{"messages": [{"role": "system", "content": "You are a coding assistant specialized in generating formal postconditions for ERC interface with solc-verify postconditions annotations."},{"role": "user", "content": "/**\n * @notice Find the owner of an NFT\n * @dev NFTs assigned to zero address are considered invalid, and queries about them throw.\n * @param _tokenId The identifier for an NFT\n * @return The address of the owner of the NFT\n*/\nfunction ownerOf(uint256 _tokenId) external view returns (address owner);"},{"role": "assistant", "content": "/// @notice postcondition _tokenOwner[_tokenId] == _owner\n/// @notice postcondition _owner != address(0)\nfunction ownerOf(uint256 _tokenId) public view returns (address owner);"}]}
{"messages": [{"role": "system", "content": "You are a coding assistant specialized in generating formal postconditions for ERC interface with solc-verify postconditions annotations."},{"role": "user", "content": "/**\n * @notice Change or reaffirm the approved address for an NFT\n * @dev The zero address indicates there is no approved address.\n * Throws unless `msg.sender` is the current NFT owner, or an authorized operator of the current owner.\n * @param _approved The new approved NFT controller\n * @param _tokenId The NFT to approve\n*/\nfunction approve(address _approved, uint256 _tokenId) external;"},{"role": "assistant", "content": "/// @notice postcondition _tokenApprovals[_tokenId] == _approved\nfunction approve(address _approved, uint256 _tokenId) external;"}]}
{"messages": [{"role": "system", "content": "You are a coding assistant specialized in generating formal postconditions for ERC interface with solc-verify postconditions annotations."},{"role": "user", "content": "/**\n * @notice Get the approved address for a single NFT\n * @dev Throws if `_tokenId` is not a valid NFT.\n * @param _tokenId The NFT to find the approved address for\n * @return The approved address for this NFT, or the zero address if there is none\n*/\nfunction getApproved(uint256 _tokenId) external view returns (address approved);"},{"role": "assistant", "content": "/// @notice postcondition _tokenOwner[_tokenId] != address(0)\n/// @notice postcondition _tokenApprovals[_tokenId] == approved\nfunction getApproved(uint256 _tokenId) external view returns (address approved);"}]}
{"messages": [{"role": "system", "content": "You are a coding assistant specialized in generating formal postconditions for ERC interface with solc-verify postconditions annotations."},{"role": "user", "content": "/**\n * @notice Enable or disable approval for a third party (\"operator\") to manage all of `msg.sender`'s assets\n * @param _operator Address to add to the set of authorized operators\n * @param _approved True if the operator is approved, false to revoke approval\n*/\nfunction setApprovalForAll(address _operator, bool _approved) external;"},{"role": "assistant", "content": "/// @notice postcondition _operatorApprovals[msg.sender][_operator] == _approved\nfunction setApprovalForAll(address _operator, bool _approved) external;"}]}
{"messages": [{"role": "system", "content": "You are a coding assistant specialized in generating formal postconditions for ERC interface with solc-verify postconditions annotations."},{"role": "user", "content": "/**\n * @notice Query if an address is an authorized operator for another address\n * @param _owner The address that owns the NFTs\n * @param _operator The address that acts on behalf of the owner\n * @return True if `_operator` is an approved operator for `_owner`, false otherwise\n*/\nfunction isApprovedForAll(address _owner, address _operator) external view returns (bool);"},{"role": "assistant", "content": "/// @notice postcondition _operatorApprovals[_owner][_operator] == approved\nfunction isApprovedForAll(address _owner, address _operator) external view returns (bool);"}]}
{"messages": [{"role": "system", "content": "You are a coding assistant specialized in generating formal postconditions for ERC interface with solc-verify postconditions annotations."},{"role": "user", "content": "/**\n * @notice Transfer ownership of an NFT\n * @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved address for this NFT.\n * Throws if `_from` is not the current owner. Throws if `_to` is the zero address. Throws if `_tokenId` is not a valid NFT.\n * @param _from The current owner of the NFT\n * @param _to The new owner\n * @param _tokenId The NFT to transfer\n*/\nfunction transferFrom(address _from, address _to, uint256 _tokenId) external;"},{"role": "assistant", "content": "/// @notice postcondition ( ( _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from]) - 1 && _from != _to ) || ( _from == _to ) )\n/// @notice postcondition ( ( _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to]) + 1 && _from != _to ) || ( _from == _to ) )\n/// @notice postcondition _tokenOwner[_tokenId] == _to\nfunction transferFrom(address _from, address _to, uint256 _tokenId) external;"}]}
{"messages": [{"role": "system", "content": "You are a coding assistant specialized in generating formal postconditions for ERC interface with solc-verify postconditions annotations."},{"role": "user", "content": "/**\n * @notice Transfers the ownership of an NFT from one address to another address with safety checks\n * @dev Identical to `transferFrom` but with an additional data parameter.\n * @param _from The current owner of the NFT\n * @param _to The new owner\n * @param _tokenId The NFT to transfer\n * @param data Additional data with no specified format\n*/\nfunction safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external;"},{"role": "assistant", "content": "/// @notice postcondition ( ( _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from]) - 1 && _from != _to ) || ( _from == _to ) )\n/// @notice postcondition ( ( _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to]) + 1 && _from != _to ) || ( _from == _to ) )\n/// @notice postcondition _tokenOwner[_tokenId] == _to\nfunction safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external;"}]}